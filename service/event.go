package service

import (
	"fmt"
	"net"

	"github.com/dmitriivoitovich/test-assignment-malwarebytes/controller/request"
	"github.com/dmitriivoitovich/test-assignment-malwarebytes/controller/response"
	"github.com/dmitriivoitovich/test-assignment-malwarebytes/repository"
	"github.com/dmitriivoitovich/test-assignment-malwarebytes/repository/db"
	"golang.org/x/sync/errgroup"
	"gorm.io/gorm"
)

const (
	speedThresholdMPH = 500
)

type Event struct {
	geoIPService    *GeoIP
	eventRepository *repository.Event
}

type EventWithLocation struct {
	event    *db.Event
	location *Location
}

var (
	ErrEventAlreadyExists = fmt.Errorf("event with this ID already exists")
)

func NewEvent(eventRepository *repository.Event, geoIP *GeoIP) *Event {
	return &Event{
		eventRepository: eventRepository,
		geoIPService:    geoIP,
	}
}

func (e *Event) AddEvent(req *request.PostEvent) (*response.PostEvent, error) {
	currentEvent, err := e.saveEvent(req)
	if err != nil {
		return nil, err
	}

	currentLocation, err := e.geoIPService.LocationByIP(uint32ToIP(currentEvent.IP))
	if err != nil {
		return nil, err
	}

	currentEventWithLocation := &EventWithLocation{
		event:    currentEvent,
		location: currentLocation,
	}

	g := new(errgroup.Group)

	var precedingIPAccess *response.IPAccess
	var subsequentIPAccess *response.IPAccess

	g.Go(func() error {
		var precedingIPAccessErr error
		precedingIPAccess, precedingIPAccessErr = e.prevIPAccess(currentEventWithLocation)

		return precedingIPAccessErr
	})

	g.Go(func() error {
		var subsequentIPAccessErr error
		subsequentIPAccess, subsequentIPAccessErr = e.nextIPAccess(currentEventWithLocation)

		return subsequentIPAccessErr
	})

	if err := g.Wait(); err != nil {
		return nil, err
	}

	resp := &response.PostEvent{
		CurrentGeo: response.CurrentGeo{
			Lat:    currentLocation.Latitude,
			Lon:    currentLocation.Longitude,
			Radius: currentLocation.AccuracyRadius,
		},
		TravelToCurrentGeoSuspicious:   e.isAccessSuspicious(precedingIPAccess),
		TravelFromCurrentGeoSuspicious: e.isAccessSuspicious(subsequentIPAccess),
		PrecedingIPAccess:              precedingIPAccess,
		SubsequentIPAccess:             subsequentIPAccess,
	}

	return resp, nil
}

func (e *Event) saveEvent(req *request.PostEvent) (*db.Event, error) {
	event := &db.Event{
		ID:        req.UUID.Bytes(),
		Username:  req.Username,
		Timestamp: req.Timestamp,
		IP:        ipToUint32(net.ParseIP(req.IP)),
	}

	if err := e.eventRepository.Insert(event); err != nil {
		if db.IsPrimaryKeyConstraintErr(err) {
			return nil, ErrEventAlreadyExists
		}

		return nil, err
	}

	return event, nil
}

func (e *Event) prevIPAccess(currentEvent *EventWithLocation) (*response.IPAccess, error) {
	prevEvent, err := e.eventRepository.Prev(currentEvent.event)
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil
		}

		return nil, err
	}

	resp, err := e.ipAccess(currentEvent, prevEvent)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (e *Event) nextIPAccess(currentEvent *EventWithLocation) (*response.IPAccess, error) {
	nextEvent, err := e.eventRepository.Next(currentEvent.event)
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil
		}

		return nil, err
	}

	resp, err := e.ipAccess(currentEvent, nextEvent)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (e *Event) ipAccess(currentEvent *EventWithLocation, nextEvent *db.Event) (*response.IPAccess, error) {
	resp := &response.IPAccess{
		Latitude:  0,
		Longitude: 0,
		Radius:    0,
		Speed:     0,
		IP:        uint32ToIP(nextEvent.IP).String(),
		Timestamp: nextEvent.Timestamp,
	}

	nextLocation, err := e.geoIPService.LocationByIP(uint32ToIP(nextEvent.IP))
	if err != nil {
		if err == ErrLocationUnknown {
			return resp, nil
		}

		return nil, err
	}

	resp.Latitude = nextLocation.Latitude
	resp.Longitude = nextLocation.Longitude
	resp.Radius = nextLocation.AccuracyRadius

	nextEventWithLocation := &EventWithLocation{
		event:    nextEvent,
		location: nextLocation,
	}

	resp.Speed = travelSpeed(currentEvent, nextEventWithLocation)

	return resp, nil
}

func (e *Event) isAccessSuspicious(ipAccess *response.IPAccess) bool {
	if ipAccess != nil {
		isCoordsUnknown := ipAccess.Latitude == 0 && ipAccess.Longitude == 0
		isSpeedOverThreshold := ipAccess.Speed > speedThresholdMPH

		return isCoordsUnknown || isSpeedOverThreshold
	}

	return false
}
