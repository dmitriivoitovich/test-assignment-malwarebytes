package service

import (
	"net"
	"testing"
	"time"

	"github.com/dmitriivoitovich/test-assignment-malwarebytes/controller/request"
	"github.com/dmitriivoitovich/test-assignment-malwarebytes/repository"
	"github.com/dmitriivoitovich/test-assignment-malwarebytes/repository/db"
	"github.com/icrowley/fake"
	"github.com/mattn/go-sqlite3"
	uuid "github.com/satori/go.uuid"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"gorm.io/gorm"
)

type EventTestSuite struct {
	suite.Suite

	geoIPServiceMock    *GeoIPMock
	eventRepositoryMock *repository.EventMock
	eventService        *Event
}

func TestEventTestSuite(t *testing.T) {
	suite.Run(t, new(EventTestSuite))
}

func (suite *EventTestSuite) SetupTest() {
	suite.geoIPServiceMock = &GeoIPMock{}
	suite.eventRepositoryMock = &repository.EventMock{}

	suite.eventService = NewEvent(suite.eventRepositoryMock, suite.geoIPServiceMock)
}

func (suite *EventTestSuite) TearDownTest() {
	suite.geoIPServiceMock.AssertExpectations(suite.T())
	suite.eventRepositoryMock.AssertExpectations(suite.T())
}

func (suite *EventTestSuite) TestAddEvent_ReturnsSuccessfulResponse_InCaseOfPrevEventDoesNotExist_NextEventDoesNotExist() {
	req := &request.PostEvent{
		UUID:      uuid.NewV4(),
		Username:  fake.UserName(),
		Timestamp: 0,
		IP:        fake.IPv4(),
	}

	loc := &Location{
		AccuracyRadius: 10,
		Latitude:       10,
		Longitude:      10,
	}

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(loc, nil).
		Once()

	suite.eventRepositoryMock.
		On("Insert", mock.Anything).
		Return(nil).
		Once()

	suite.eventRepositoryMock.
		On("Next", mock.Anything).
		Return(nil, gorm.ErrRecordNotFound).
		Once()

	suite.eventRepositoryMock.
		On("Prev", mock.Anything).
		Return(nil, gorm.ErrRecordNotFound).
		Once()

	resp, err := suite.eventService.AddEvent(req)
	suite.NoError(err)

	suite.Equal(loc.Latitude, resp.CurrentGeo.Lat)
	suite.Equal(loc.Longitude, resp.CurrentGeo.Lon)
	suite.Equal(loc.AccuracyRadius, resp.CurrentGeo.Radius)

	suite.False(resp.TravelFromCurrentGeoSuspicious)
	suite.False(resp.TravelToCurrentGeoSuspicious)
	suite.Nil(resp.PrecedingIPAccess)
	suite.Nil(resp.SubsequentIPAccess)
}

func (suite *EventTestSuite) TestAddEvent_ReturnsError_InCaseOfUnknownLocation() {
	req := &request.PostEvent{
		UUID:      uuid.NewV4(),
		Username:  fake.UserName(),
		Timestamp: 0,
		IP:        fake.IPv4(),
	}

	loc := &Location{
		AccuracyRadius: 0,
		Latitude:       0,
		Longitude:      0,
	}

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(loc, ErrLocationUnknown).
		Once()

	suite.eventRepositoryMock.
		On("Insert", mock.Anything).
		Return(nil).
		Once()

	resp, err := suite.eventService.AddEvent(req)
	suite.Nil(resp)
	suite.Error(err)
	suite.ErrorIs(err, ErrLocationUnknown)
}

func (suite *EventTestSuite) TestAddEvent_ReturnsError_InCaseOfDuplicatedEvent() {
	req := &request.PostEvent{
		UUID:      uuid.NewV4(),
		Username:  fake.UserName(),
		Timestamp: 0,
		IP:        fake.IPv4(),
	}

	suite.eventRepositoryMock.
		On("Insert", mock.Anything).
		Return(sqlite3.Error{ExtendedCode: db.ErrCodeSqliteConstraintPrimaryKey}).
		Once()

	resp, err := suite.eventService.AddEvent(req)
	suite.Nil(resp)
	suite.Error(err)
	suite.ErrorIs(err, ErrEventAlreadyExists)
}

func (suite *EventTestSuite) TestAddEvent_ReturnsSuccessfulResponse_InCaseOfPrevEventExists_LocationUnknown() {
	req := &request.PostEvent{
		UUID:      uuid.NewV4(),
		Username:  fake.UserName(),
		Timestamp: 0,
		IP:        fake.IPv4(),
	}

	eventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       0,
		Longitude:      0,
	}

	suite.eventRepositoryMock.
		On("Insert", mock.Anything).
		Return(nil).
		Once()

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(eventLoc, nil).
		Once()

	prevEvent := &db.Event{
		ID:        uuid.NewV4().Bytes(),
		Username:  fake.IPv4(),
		Timestamp: 0,
		IP:        ipToUint32(net.ParseIP(fake.IPv4())),
	}
	suite.eventRepositoryMock.
		On("Prev", mock.Anything).
		Return(prevEvent, nil).
		Once()

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(nil, ErrLocationUnknown).
		Once()

	suite.eventRepositoryMock.
		On("Next", mock.Anything).
		Return(nil, gorm.ErrRecordNotFound).
		Once()

	resp, err := suite.eventService.AddEvent(req)
	suite.NoError(err)

	suite.Equal(eventLoc.Latitude, resp.CurrentGeo.Lat)
	suite.Equal(eventLoc.Longitude, resp.CurrentGeo.Lon)
	suite.Equal(eventLoc.AccuracyRadius, resp.CurrentGeo.Radius)

	suite.False(resp.TravelFromCurrentGeoSuspicious)
	suite.True(resp.TravelToCurrentGeoSuspicious)

	if suite.NotNil(resp.PrecedingIPAccess) {
		suite.Zero(resp.PrecedingIPAccess.Latitude)
		suite.Zero(resp.PrecedingIPAccess.Longitude)
		suite.Zero(resp.PrecedingIPAccess.Radius)
		suite.Equal(uint32ToIP(prevEvent.IP).String(), resp.PrecedingIPAccess.IP)
		suite.Zero(resp.PrecedingIPAccess.Speed)
		suite.Equal(prevEvent.Timestamp, resp.PrecedingIPAccess.Timestamp)
	}

	suite.Nil(resp.SubsequentIPAccess)
}

func (suite *EventTestSuite) TestAddEvent_ReturnsSuccessfulResponse_InCaseOfPrevEventExists_ThresholdExceeded() {
	expectedSpeed := 960

	req := &request.PostEvent{
		UUID:      uuid.NewV4(),
		Username:  fake.UserName(),
		Timestamp: uint64(time.Hour.Seconds()),
		IP:        fake.IPv4(),
	}

	eventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       20,
		Longitude:      20,
	}

	suite.eventRepositoryMock.
		On("Insert", mock.Anything).
		Return(nil).
		Once()

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(eventLoc, nil).
		Once()

	prevEvent := &db.Event{
		ID:        uuid.NewV4().Bytes(),
		Username:  fake.IPv4(),
		Timestamp: 0,
		IP:        ipToUint32(net.ParseIP(fake.IPv4())),
	}

	suite.eventRepositoryMock.
		On("Prev", mock.Anything).
		Return(prevEvent, nil).
		Once()

	prevEventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       10,
		Longitude:      10,
	}

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(prevEventLoc, nil).
		Once()

	suite.eventRepositoryMock.
		On("Next", mock.Anything).
		Return(nil, gorm.ErrRecordNotFound).
		Once()

	resp, err := suite.eventService.AddEvent(req)
	suite.NoError(err)

	suite.Equal(eventLoc.Latitude, resp.CurrentGeo.Lat)
	suite.Equal(eventLoc.Longitude, resp.CurrentGeo.Lon)
	suite.Equal(eventLoc.AccuracyRadius, resp.CurrentGeo.Radius)

	suite.False(resp.TravelFromCurrentGeoSuspicious)
	suite.True(resp.TravelToCurrentGeoSuspicious)

	if suite.NotNil(resp.PrecedingIPAccess) {
		suite.Equal(prevEventLoc.Latitude, resp.PrecedingIPAccess.Latitude)
		suite.Equal(prevEventLoc.Longitude, resp.PrecedingIPAccess.Longitude)
		suite.Equal(prevEventLoc.AccuracyRadius, resp.PrecedingIPAccess.Radius)
		suite.Equal(uint32ToIP(prevEvent.IP).String(), resp.PrecedingIPAccess.IP)
		suite.Equal(expectedSpeed, int(resp.PrecedingIPAccess.Speed))
		suite.Equal(prevEvent.Timestamp, resp.PrecedingIPAccess.Timestamp)
	}

	suite.Nil(resp.SubsequentIPAccess)
}

func (suite *EventTestSuite) TestAddEvent_ReturnsSuccessfulResponse_InCaseOfPrevEventExists_ThresholdNotExceeded() {
	expectedSpeed := 960 / 2

	req := &request.PostEvent{
		UUID:      uuid.NewV4(),
		Username:  fake.UserName(),
		Timestamp: uint64(time.Hour.Seconds() * 2),
		IP:        fake.IPv4(),
	}

	eventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       20,
		Longitude:      20,
	}

	suite.eventRepositoryMock.
		On("Insert", mock.Anything).
		Return(nil).
		Once()

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(eventLoc, nil).
		Once()

	prevEvent := &db.Event{
		ID:        uuid.NewV4().Bytes(),
		Username:  fake.IPv4(),
		Timestamp: 0,
		IP:        ipToUint32(net.ParseIP(fake.IPv4())),
	}

	suite.eventRepositoryMock.
		On("Prev", mock.Anything).
		Return(prevEvent, nil).
		Once()

	prevEventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       10,
		Longitude:      10,
	}

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(prevEventLoc, nil).
		Once()

	suite.eventRepositoryMock.
		On("Next", mock.Anything).
		Return(nil, gorm.ErrRecordNotFound).
		Once()

	resp, err := suite.eventService.AddEvent(req)
	suite.NoError(err)

	suite.Equal(eventLoc.Latitude, resp.CurrentGeo.Lat)
	suite.Equal(eventLoc.Longitude, resp.CurrentGeo.Lon)
	suite.Equal(eventLoc.AccuracyRadius, resp.CurrentGeo.Radius)

	suite.False(resp.TravelFromCurrentGeoSuspicious)
	suite.False(resp.TravelToCurrentGeoSuspicious)

	if suite.NotNil(resp.PrecedingIPAccess) {
		suite.Equal(prevEventLoc.Latitude, resp.PrecedingIPAccess.Latitude)
		suite.Equal(prevEventLoc.Longitude, resp.PrecedingIPAccess.Longitude)
		suite.Equal(prevEventLoc.AccuracyRadius, resp.PrecedingIPAccess.Radius)
		suite.Equal(uint32ToIP(prevEvent.IP).String(), resp.PrecedingIPAccess.IP)
		suite.Equal(expectedSpeed, int(resp.PrecedingIPAccess.Speed))
		suite.Equal(prevEvent.Timestamp, resp.PrecedingIPAccess.Timestamp)
	}

	suite.Nil(resp.SubsequentIPAccess)
}

func (suite *EventTestSuite) TestAddEvent_ReturnsSuccessfulResponse_InCaseOfNextEventExists_LocationUnknown() {
	req := &request.PostEvent{
		UUID:      uuid.NewV4(),
		Username:  fake.UserName(),
		Timestamp: 0,
		IP:        fake.IPv4(),
	}

	eventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       10,
		Longitude:      10,
	}

	suite.eventRepositoryMock.
		On("Insert", mock.Anything).
		Return(nil).
		Once()

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(eventLoc, nil).
		Once()

	nextEvent := &db.Event{
		ID:        uuid.NewV4().Bytes(),
		Username:  fake.IPv4(),
		Timestamp: 0,
		IP:        ipToUint32(net.ParseIP(fake.IPv4())),
	}
	suite.eventRepositoryMock.
		On("Next", mock.Anything).
		Return(nextEvent, nil).
		Once()

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(nil, ErrLocationUnknown).
		Once()

	suite.eventRepositoryMock.
		On("Prev", mock.Anything).
		Return(nil, gorm.ErrRecordNotFound).
		Once()

	resp, err := suite.eventService.AddEvent(req)
	suite.NoError(err)

	suite.Equal(eventLoc.Latitude, resp.CurrentGeo.Lat)
	suite.Equal(eventLoc.Longitude, resp.CurrentGeo.Lon)
	suite.Equal(eventLoc.AccuracyRadius, resp.CurrentGeo.Radius)

	suite.True(resp.TravelFromCurrentGeoSuspicious)
	suite.False(resp.TravelToCurrentGeoSuspicious)

	if suite.NotNil(resp.SubsequentIPAccess) {
		suite.Zero(resp.SubsequentIPAccess.Latitude)
		suite.Zero(resp.SubsequentIPAccess.Longitude)
		suite.Zero(resp.SubsequentIPAccess.Radius)
		suite.Equal(uint32ToIP(nextEvent.IP).String(), resp.SubsequentIPAccess.IP)
		suite.Zero(resp.SubsequentIPAccess.Speed)
		suite.Equal(nextEvent.Timestamp, resp.SubsequentIPAccess.Timestamp)
	}

	suite.Nil(resp.PrecedingIPAccess)
}

func (suite *EventTestSuite) TestAddEvent_ReturnsSuccessfulResponse_InCaseOfNextEventExists_ThresholdExceeded() {
	expectedSpeed := 960

	req := &request.PostEvent{
		UUID:      uuid.NewV4(),
		Username:  fake.UserName(),
		Timestamp: uint64(time.Hour.Seconds()),
		IP:        fake.IPv4(),
	}

	eventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       10,
		Longitude:      10,
	}

	suite.eventRepositoryMock.
		On("Insert", mock.Anything).
		Return(nil).
		Once()

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(eventLoc, nil).
		Once()

	nextEvent := &db.Event{
		ID:        uuid.NewV4().Bytes(),
		Username:  fake.IPv4(),
		Timestamp: 0,
		IP:        ipToUint32(net.ParseIP(fake.IPv4())),
	}

	suite.eventRepositoryMock.
		On("Next", mock.Anything).
		Return(nextEvent, nil).
		Once()

	nextEventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       20,
		Longitude:      20,
	}

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(nextEventLoc, nil).
		Once()

	suite.eventRepositoryMock.
		On("Prev", mock.Anything).
		Return(nil, gorm.ErrRecordNotFound).
		Once()

	resp, err := suite.eventService.AddEvent(req)
	suite.NoError(err)

	suite.Equal(eventLoc.Latitude, resp.CurrentGeo.Lat)
	suite.Equal(eventLoc.Longitude, resp.CurrentGeo.Lon)
	suite.Equal(eventLoc.AccuracyRadius, resp.CurrentGeo.Radius)

	suite.True(resp.TravelFromCurrentGeoSuspicious)
	suite.False(resp.TravelToCurrentGeoSuspicious)

	if suite.NotNil(resp.SubsequentIPAccess) {
		suite.Equal(nextEventLoc.Latitude, resp.SubsequentIPAccess.Latitude)
		suite.Equal(nextEventLoc.Longitude, resp.SubsequentIPAccess.Longitude)
		suite.Equal(nextEventLoc.AccuracyRadius, resp.SubsequentIPAccess.Radius)
		suite.Equal(uint32ToIP(nextEvent.IP).String(), resp.SubsequentIPAccess.IP)
		suite.Equal(expectedSpeed, int(resp.SubsequentIPAccess.Speed))
		suite.Equal(nextEvent.Timestamp, resp.SubsequentIPAccess.Timestamp)
	}

	suite.Nil(resp.PrecedingIPAccess)
}

func (suite *EventTestSuite) TestAddEvent_ReturnsSuccessfulResponse_InCaseOfNextEventExists_ThresholdNotExceeded() {
	expectedSpeed := 960 / 2

	req := &request.PostEvent{
		UUID:      uuid.NewV4(),
		Username:  fake.UserName(),
		Timestamp: uint64(time.Hour.Seconds() * 2),
		IP:        fake.IPv4(),
	}

	eventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       10,
		Longitude:      10,
	}

	suite.eventRepositoryMock.
		On("Insert", mock.Anything).
		Return(nil).
		Once()

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(eventLoc, nil).
		Once()

	nextEvent := &db.Event{
		ID:        uuid.NewV4().Bytes(),
		Username:  fake.IPv4(),
		Timestamp: 0,
		IP:        ipToUint32(net.ParseIP(fake.IPv4())),
	}

	suite.eventRepositoryMock.
		On("Next", mock.Anything).
		Return(nextEvent, nil).
		Once()

	nextEventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       20,
		Longitude:      20,
	}

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(nextEventLoc, nil).
		Once()

	suite.eventRepositoryMock.
		On("Prev", mock.Anything).
		Return(nil, gorm.ErrRecordNotFound).
		Once()

	resp, err := suite.eventService.AddEvent(req)
	suite.NoError(err)

	suite.Equal(eventLoc.Latitude, resp.CurrentGeo.Lat)
	suite.Equal(eventLoc.Longitude, resp.CurrentGeo.Lon)
	suite.Equal(eventLoc.AccuracyRadius, resp.CurrentGeo.Radius)

	suite.False(resp.TravelFromCurrentGeoSuspicious)
	suite.False(resp.TravelToCurrentGeoSuspicious)

	if suite.NotNil(resp.SubsequentIPAccess) {
		suite.Equal(nextEventLoc.Latitude, resp.SubsequentIPAccess.Latitude)
		suite.Equal(nextEventLoc.Longitude, resp.SubsequentIPAccess.Longitude)
		suite.Equal(nextEventLoc.AccuracyRadius, resp.SubsequentIPAccess.Radius)
		suite.Equal(uint32ToIP(nextEvent.IP).String(), resp.SubsequentIPAccess.IP)
		suite.Equal(expectedSpeed, int(resp.SubsequentIPAccess.Speed))
		suite.Equal(nextEvent.Timestamp, resp.SubsequentIPAccess.Timestamp)
	}

	suite.Nil(resp.PrecedingIPAccess)
}

func (suite *EventTestSuite) TestAddEvent_ReturnsSuccessfulResponse_InCaseOfNextEventExists_PrevEventExists_ThresholdNotExceeded() {
	expectedSpeed := 960 / 2

	req := &request.PostEvent{
		UUID:      uuid.NewV4(),
		Username:  fake.UserName(),
		Timestamp: uint64(time.Hour.Seconds() * 2),
		IP:        fake.IPv4(),
	}

	eventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       20,
		Longitude:      20,
	}

	suite.eventRepositoryMock.
		On("Insert", mock.Anything).
		Return(nil).
		Once()

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(eventLoc, nil).
		Once()

	prevEvent := &db.Event{
		ID:        uuid.NewV4().Bytes(),
		Username:  fake.IPv4(),
		Timestamp: 0,
		IP:        ipToUint32(net.ParseIP(fake.IPv4())),
	}

	suite.eventRepositoryMock.
		On("Prev", mock.Anything).
		Return(prevEvent, nil).
		Once()

	prevEventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       10,
		Longitude:      10,
	}

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(prevEventLoc, nil).
		Once()

	nextEvent := &db.Event{
		ID:        uuid.NewV4().Bytes(),
		Username:  fake.IPv4(),
		Timestamp: uint64(time.Hour.Seconds() * 4),
		IP:        ipToUint32(net.ParseIP(fake.IPv4())),
	}

	suite.eventRepositoryMock.
		On("Next", mock.Anything).
		Return(nextEvent, nil).
		Once()

	nextEventLoc := &Location{
		AccuracyRadius: 0,
		Latitude:       10,
		Longitude:      10,
	}

	suite.geoIPServiceMock.
		On("LocationByIP", mock.Anything).
		Return(nextEventLoc, nil).
		Once()

	resp, err := suite.eventService.AddEvent(req)
	suite.NoError(err)

	suite.Equal(eventLoc.Latitude, resp.CurrentGeo.Lat)
	suite.Equal(eventLoc.Longitude, resp.CurrentGeo.Lon)
	suite.Equal(eventLoc.AccuracyRadius, resp.CurrentGeo.Radius)

	suite.False(resp.TravelFromCurrentGeoSuspicious)
	suite.False(resp.TravelToCurrentGeoSuspicious)

	if suite.NotNil(resp.PrecedingIPAccess) {
		suite.Equal(prevEventLoc.Latitude, resp.PrecedingIPAccess.Latitude)
		suite.Equal(prevEventLoc.Longitude, resp.PrecedingIPAccess.Longitude)
		suite.Equal(prevEventLoc.AccuracyRadius, resp.PrecedingIPAccess.Radius)
		suite.Equal(uint32ToIP(prevEvent.IP).String(), resp.PrecedingIPAccess.IP)
		suite.Equal(expectedSpeed, int(resp.PrecedingIPAccess.Speed))
		suite.Equal(prevEvent.Timestamp, resp.PrecedingIPAccess.Timestamp)
	}

	if suite.NotNil(resp.SubsequentIPAccess) {
		suite.Equal(nextEventLoc.Latitude, resp.SubsequentIPAccess.Latitude)
		suite.Equal(nextEventLoc.Longitude, resp.SubsequentIPAccess.Longitude)
		suite.Equal(nextEventLoc.AccuracyRadius, resp.SubsequentIPAccess.Radius)
		suite.Equal(uint32ToIP(nextEvent.IP).String(), resp.SubsequentIPAccess.IP)
		suite.Equal(expectedSpeed, int(resp.SubsequentIPAccess.Speed))
		suite.Equal(nextEvent.Timestamp, resp.SubsequentIPAccess.Timestamp)
	}
}
