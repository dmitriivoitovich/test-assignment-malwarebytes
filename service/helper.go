package service

import (
	"encoding/binary"
	"math"
	"net"

	"github.com/umahmood/haversine"
)

const (
	maxUint64               = ^uint64(0)
	kilometersToMilesFactor = 0.6214
)

func ipToUint32(ip net.IP) uint32 {
	if len(ip) == 16 {
		return binary.BigEndian.Uint32(ip[12:16])
	}

	return binary.BigEndian.Uint32(ip)
}

func uint32ToIP(nn uint32) net.IP {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, nn)

	return ip
}

func travelSpeed(from, to *EventWithLocation) uint64 {
	fromCoord := haversine.Coord{
		Lat: from.location.Latitude,
		Lon: from.location.Longitude,
	}

	toCoord := haversine.Coord{
		Lat: to.location.Latitude,
		Lon: to.location.Longitude,
	}

	_, km := haversine.Distance(fromCoord, toCoord)

	if km > 0 {
		km += float64(from.location.AccuracyRadius) + float64(to.location.AccuracyRadius)
	}

	var seconds uint64
	if from.event.Timestamp < to.event.Timestamp {
		seconds = to.event.Timestamp - from.event.Timestamp
	} else {
		seconds = from.event.Timestamp - to.event.Timestamp
	}

	if seconds == 0 {
		if km == 0 {
			return 0
		} else {
			return maxUint64
		}
	}

	speed := math.Round(km / (float64(seconds) / 3600))

	return uint64(kilometersToMiles(speed))
}

func kilometersToMiles(km float64) float64 {
	if km == 0 {
		return 0
	}

	return math.Round(km * kilometersToMilesFactor)
}
